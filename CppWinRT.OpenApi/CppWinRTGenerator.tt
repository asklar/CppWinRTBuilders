<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// This file was automatically generated by CppWinRT.OpenApi
// from the OpenAPI specification at <#= SpecificationUrl #>
// (<#= OpenApiPath #>)
// Do not edit this file directly, as it will be overwritten.
// Using server: <#= ServerDescription #> -> <#= ServerUri #>

#include <winrt/Windows.Data.Json.h>
#include <winrt/Windows.Foundation.h>
#include <winrt/Windows.Foundation.Collections.h>
#include <winrt/Windows.System.h>
#include <winrt/Windows.Web.Http.h>
#include <winrt/Windows.Web.Http.Headers.h>
#include <wil/coroutine.h>
#include <format>
#include <array>
#include <numeric>
// <#= Title #>
// Version <#= Version #>

namespace <#= Namespace #>::<#= ApiName #>
{
enum class ServerEnvironment
{
    Default = 0,
<# foreach (var server in Servers) { #>
    <#= server.Key.Replace(" ", "_") #>,
<# } #>
};

struct ServerConfig
{
    ServerEnvironment environment;
    std::wstring_view uri;
};

constexpr std::array ServerConfigList =
{
    ServerConfig{ServerEnvironment::Default, L"<#= ServerUri #>"},
<# foreach (var server in Servers) { #>
    ServerConfig{ServerEnvironment::<#= server.Key.Replace(" ", "_") #>, L"<#= server.Value #>"},
<# } #>
};

namespace details
{
template<typename T>
struct HasSendRequestAsync
{
  template<typename U, typename = decltype(std::declval<U>().SendRequestAsync(std::declval<winrt::Windows::Web::Http::HttpRequestMessage>()))>
  static std::true_type test(int);

  template<typename>
  static std::false_type test(...);

  static constexpr bool value = decltype(test<T>(0))::value;
};

template<typename T>
struct HasClose
{
  template<typename U, typename = decltype(std::declval<U>().Close())>
  static std::true_type test(int);

  template<typename>
  static std::false_type test(...);

  static constexpr bool value = decltype(test<T>(0))::value;
};

template<typename T>
constexpr bool IsHttpClientIsh_v = HasSendRequestAsync<T>::value && HasClose<T>::value;

}

<# foreach (var security in Security) { #>
<#= security.Value.GetCppDefinition() #>
<# } #>

<# foreach (var newType in GetGraphOrderedCustomTypes().Where(x => x.Key != "null")) { #>

struct <#= newType.Value.CppWinRTName.ToCamelCase() #>
{
<# foreach (var property in newType.Value.Members) { #>
    <#= LookupType(property.Schema.JsonName).CppWinRTFullName #> <#= property.Name #>{};
<# } #>
    <#= newType.Value.CppWinRTName.ToCamelCase() #>() = default;

<# if (!newType.Value.IsArray) { #>
    <#= newType.Value.CppWinRTName.ToCamelCase() #>(const winrt::Windows::Data::Json::JsonObject& json)
    {
<# foreach (var property in newType.Value.Members) {
     if (!property.Required) { #>
        if (json.HasKey(L"<#= property.Name #>"))
<#   } #>
        {
            <#= property.Name #> = <#= GetCppCast(property.Schema.JsonName) #>(json.<#= JsonObjectMethod(property) #>(L"<#= property.Name #>"));
        }
<# } #>
    }
<# } else { 
    var elementType = GetArrayElementType(newType.Value);
    var elementTypeCppWinRT = elementType.CppWinRTFullName;
    var getFromJsonMethodName = GetFromJsonMethodName(elementType);
#>
    std::vector<<#= elementTypeCppWinRT #>> items;
    auto& operator[](size_t index) { return items[index]; }
    const auto& operator[](size_t index) const { return items[index]; }
    auto empty() const { return items.empty(); }
    auto size() const { return items.size(); }
    void clear() { items.clear(); }

    <#= newType.Value.CppWinRTName.ToCamelCase() #>(const winrt::Windows::Data::Json::JsonArray& json)
    {
        for (const auto& e : json)
        {
            items.emplace_back(std::move(<#= elementTypeCppWinRT #>{e.<#= getFromJsonMethodName #>()}));
        }
<# foreach (var property in newType.Value.Members) { #>
    <#= property.Name #> = json.<#= JsonObjectMethod(property) #>(L"<#= property.Name #>");
<# } #>
    }
<# } #>

    winrt::Windows::Data::Json::IJsonValue ToJsonValue() const
    {
<# if (!newType.Value.IsArray) { #>
        auto json = winrt::Windows::Data::Json::JsonObject();
<# foreach (var property in newType.Value.Members) { #>
        json.Insert(L"<#= property.Name #>", <#= CreateValueMethodName(property.Schema) #>(<#= property.Name #>));
<# } #>
<# } else {
    var elementType = GetArrayElementType(newType.Value);
    var createValueMethodName = CreateValueMethodName(elementType);
#>
        auto json = winrt::Windows::Data::Json::JsonArray();
        for (const auto& e : items)
        {
            json.Append(<#= createValueMethodName #>(e));
        }
<# } #>
        return json;
    }

    static auto ToJsonValue(const <#= newType.Value.CppWinRTName.ToCamelCase() #>& value)
    {
        return value.ToJsonValue();
    }
};

<# } #>


// APIs

template<typename THttpClient = winrt::Windows::Web::Http::HttpClient, std::enable_if_t<details::IsHttpClientIsh_v<THttpClient>, int> = 0>
struct Api
{
    THttpClient _client;
    ServerEnvironment _serverEnvironment = ServerEnvironment::Default;

    Api(THttpClient client) : _client(client) {}
    Api() = default;
    ~Api()
    {
        if constexpr (details::HasClose<THttpClient>::value)
        {
            _client.Close();
        }
    }

    auto ServerUri() const
    {
        return std::find_if(ServerConfigList.begin(), ServerConfigList.end(), 
            [e = _serverEnvironment](const auto& config) { return config.environment == e; })->uri;
    }
<# foreach (var path in Paths) { 
var TSecuritySchemaTemplateTypeParam = (path.Security != null && path.Security.Count() > 0) ? $"template<typename TSecuritySchema = {path.DefaultSecurityCppType}>" : string.Empty;
#>
<#= path.DoxygenComment #>
<#= TSecuritySchemaTemplateTypeParam #>
<# System.Diagnostics.Debug.WriteLine(path.PathUriTemplate);#>
wil::com_task<<#= path.ResponseType.CppWinRTFullName #>> <#= GetPathCppName(path) #>(<#= GetCppWinRTParameters(path) #>)
{
    const auto serverUri = ServerUri();
    auto path = std::format(<#= ConstructPath(path) #>);
    winrt::Windows::Data::Json::JsonObject jsonBody;
<# if (path.RequestBody != null) { #>
<#   foreach (var property in path.RequestBody.Properties) { #>
    auto jsonValue_<#= property.Name #> = <#= CreateValueMethodName(property.Schema) #>(<#= property.Name #>);
    jsonBody.Insert(L"<#= property.Name #>", jsonValue_<#= property.Name #>);
<#   } 
  } #>
    auto jsonPayload = jsonBody.Stringify();

    auto request = winrt::Windows::Web::Http::HttpRequestMessage(winrt::Windows::Web::Http::HttpMethod::<#= path.Method #>(), winrt::Windows::Foundation::Uri(path));
    request.Content(winrt::Windows::Web::Http::HttpStringContent(jsonPayload, winrt::Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));
<# if (path.Security != null && path.Security.Count() > 0) { #>
    _security.apply(request, _client);
<# } #>
    auto response = co_await _client.SendRequestAsync(request);
    auto responseContent = co_await response.Content().ReadAsStringAsync();
    if (!response.IsSuccessStatusCode())
    {
        const auto errorJson = winrt::Windows::Data::Json::JsonObject::Parse(responseContent);
        const auto statusCode = static_cast<int32_t>(response.StatusCode());
        const auto hresult = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_HTTP, statusCode);
        throw winrt::hresult_error(hresult, errorJson.GetNamedString(L"message"));
    }

<# if (path.ResponseType.IsArray) { #>
    winrt::Windows::Data::Json::JsonArray responseJson;
    if (winrt::Windows::Data::Json::JsonArray::TryParse(responseContent, responseJson))
    {
<# } else { #>
    winrt::Windows::Data::Json::JsonObject responseJson;
    if (winrt::Windows::Data::Json::JsonObject::TryParse(responseContent, responseJson))
    {
<# } 
      if (path.ResponseType.JsonName == "null") { #>
        co_return responseJson;
<# } else { #>
        // parse the json as <#= path.ResponseType.CppWinRTName #>
        co_return <#= path.ResponseType.CppWinRTFullName #>{responseJson};
<# } #>
    }
    else
    {
<# if (path.ResponseType.JsonName == "null") { #>
        responseJson.Insert(L"result", winrt::Windows::Data::Json::JsonValue::CreateStringValue(responseContent));
        co_return responseJson;
<# } else { #>
        throw winrt::hresult_error(E_FAIL, L"Failed to parse response as JSON");
<# } #>
    }
}
<# } #>
};

template<typename TFunctor>
struct FunctorHttpClient
{
    TFunctor _functor;
    FunctorHttpClient(TFunctor&& functor) : _functor(std::move(functor)) {}
    wil::com_task<winrt::Windows::Web::Http::HttpResponseMessage> SendRequestAsync(winrt::Windows::Web::Http::HttpRequestMessage request)
    {
        auto response_from_json = [](std::wstring_view jsonStr)
            {
                auto response = winrt::Windows::Web::Http::HttpResponseMessage(winrt::Windows::Web::Http::HttpStatusCode::Ok);
                response.Content(winrt::Windows::Web::Http::HttpStringContent(jsonStr, winrt::Windows::Storage::Streams::UnicodeEncoding::Utf8, L"application/json"));
                return response;
            };
        if constexpr (std::is_invocable_v<TFunctor, winrt::Windows::Web::Http::HttpRequestMessage>)
        {
            co_return response_from_json(_functor(request).Stringify());
        }
        else if constexpr (std::is_invocable_v<TFunctor>)
        {
            co_return response_from_json(_functor().Stringify());
        }
        else
        {
            static_assert(std::_Always_false<TFunctor>, "FunctorHttpClient must be constructed with a functor that takes either no arguments or an HttpRequestMessage");
        }
    }
    void Close() noexcept {}
};
}